{"project":{"paths":{"base":"/home/rett/open/artifact","code_paths":["/home/rett/open/artifact/artifact-data/src","/home/rett/open/artifact/artifact-frontend/src","/home/rett/open/artifact/artifact-lib/src","/home/rett/open/artifact/artifact-ser/src","/home/rett/open/artifact/artifact-test/src","/home/rett/open/artifact/src","/home/rett/open/artifact/tests"],"exclude_code_paths":[],"artifact_paths":["/home/rett/open/artifact/design"],"exclude_artifact_paths":[]},"code_impls":{"SPC-cli":{"primary":{"file":"/home/rett/open/artifact/src/lib.rs","line":59},"secondary":{".check":{"file":"/home/rett/open/artifact/src/check.rs","line":34},".fmt":{"file":"/home/rett/open/artifact/src/fmt.rs","line":38},".serve":{"file":"/home/rett/open/artifact/src/serve/mod.rs","line":16}}},"SPC-cli-ls":{"primary":{"file":"/home/rett/open/artifact/src/ls.rs","line":16},"secondary":{".args":{"file":"/home/rett/open/artifact/src/ls.rs","line":31},".color_name":{"file":"/home/rett/open/artifact/src/ls.rs","line":597},".color_spc":{"file":"/home/rett/open/artifact/src/ls.rs","line":574},".color_tst":{"file":"/home/rett/open/artifact/src/ls.rs","line":586}}},"SPC-family":{"primary":null,"secondary":{".lint_partof_exists":{"file":"/home/rett/open/artifact/artifact-data/src/project.rs","line":163},".lint_types":{"file":"/home/rett/open/artifact/artifact-data/src/project.rs","line":183}}},"SPC-lint":{"primary":{"file":"/home/rett/open/artifact/artifact-ser/src/lint.rs","line":16},"secondary":{}},"SPC-modify":{"primary":{"file":"/home/rett/open/artifact/artifact-data/src/modify.rs","line":0},"secondary":{".backup":{"file":"/home/rett/open/artifact/artifact-data/src/modify.rs","line":229}}},"SPC-modify-update":{"primary":{"file":"/home/rett/open/artifact/artifact-data/src/modify.rs","line":184},"secondary":{}},"SPC-name":{"primary":{"file":"/home/rett/open/artifact/artifact-ser/src/name.rs","line":16},"secondary":{".attrs":{"file":"/home/rett/open/artifact/artifact-ser/src/name.rs","line":210},".type":{"file":"/home/rett/open/artifact/artifact-ser/src/name.rs","line":98}}},"SPC-read-artifact":{"primary":{"file":"/home/rett/open/artifact/artifact-data/src/artifact.rs","line":17},"secondary":{".build":{"file":"/home/rett/open/artifact/artifact-data/src/artifact.rs","line":57},".completed":{"file":"/home/rett/open/artifact/artifact-data/src/graph.rs","line":71},".graph":{"file":"/home/rett/open/artifact/artifact-data/src/graph.rs","line":33},".lint_done":{"file":"/home/rett/open/artifact/artifact-data/src/project.rs","line":214},".lint_text":{"file":"/home/rett/open/artifact/artifact-data/src/project.rs","line":300},".lint_text_refs":{"file":"/home/rett/open/artifact/artifact-data/src/project.rs","line":335},".load":{"file":"/home/rett/open/artifact/artifact-data/src/artifact.rs","line":33}}},"SPC-read-family":{"primary":{"file":"/home/rett/open/artifact/artifact-ser/src/family.rs","line":16},"secondary":{".auto":{"file":"/home/rett/open/artifact/artifact-ser/src/family.rs","line":159},".auto_partof":{"file":"/home/rett/open/artifact/artifact-ser/src/family.rs","line":97},".deauto":{"file":"/home/rett/open/artifact/artifact-ser/src/lib.rs","line":277},".parent":{"file":"/home/rett/open/artifact/artifact-ser/src/family.rs","line":85}}},"SPC-read-impl":{"primary":{"file":"/home/rett/open/artifact/artifact-data/src/implemented.rs","line":16},"secondary":{".join":{"file":"/home/rett/open/artifact/artifact-data/src/implemented.rs","line":100},".lint_done":{"file":"/home/rett/open/artifact/artifact-data/src/project.rs","line":252},".lint_exists":{"file":"/home/rett/open/artifact/artifact-data/src/project.rs","line":264},".lint_subname_exists":{"file":"/home/rett/open/artifact/artifact-data/src/project.rs","line":278},".load":{"file":"/home/rett/open/artifact/artifact-data/src/implemented.rs","line":65}}},"SPC-read-raw-markdown":{"primary":{"file":"/home/rett/open/artifact/artifact-data/src/raw.rs","line":176},"secondary":{}},"SPC-structs":{"primary":null,"secondary":{".artifact":{"file":"/home/rett/open/artifact/artifact-lib/src/lib.rs","line":51},".artifact_im":{"file":"/home/rett/open/artifact/artifact-lib/src/lib.rs","line":231},".artifact_op":{"file":"/home/rett/open/artifact/artifact-lib/src/lib.rs","line":301}}},"TST-framework":{"primary":{"file":"/home/rett/open/artifact/artifact-test/src/framework.rs","line":16},"secondary":{}},"TST-fuzz":{"primary":{"file":"/home/rett/open/artifact/artifact-test/src/lib.rs","line":21},"secondary":{".artifact":{"file":"/home/rett/open/artifact/tests/data_artifact.rs","line":18},".family":{"file":"/home/rett/open/artifact/tests/data_family.rs","line":18},".name":{"file":"/home/rett/open/artifact/tests/data_name.rs","line":18},".raw_name":{"file":"/home/rett/open/artifact/tests/data_raw_names.rs","line":18},".read_impl":{"file":"/home/rett/open/artifact/tests/data_implemented.rs","line":18}}},"TST-read-artifact":{"primary":{"file":"/home/rett/open/artifact/tests/data_interop.rs","line":17},"secondary":{".basic":{"file":"/home/rett/open/artifact/tests/data_interop.rs","line":99},".design_only":{"file":"/home/rett/open/artifact/tests/data_interop.rs","line":93},".empty":{"file":"/home/rett/open/artifact/tests/data_interop.rs","line":75},".lints":{"file":"/home/rett/open/artifact/tests/data_interop.rs","line":105},".source_invalid":{"file":"/home/rett/open/artifact/tests/data_interop.rs","line":87},".source_only":{"file":"/home/rett/open/artifact/tests/data_interop.rs","line":81}}},"TST-read-raw":{"primary":{"file":"/home/rett/open/artifact/artifact-test/src/raw.rs","line":16},"secondary":{}},"TST-unit":{"primary":{"file":"/home/rett/open/artifact/artifact-test/src/lib.rs","line":20},"secondary":{".artifact":{"file":"/home/rett/open/artifact/tests/data_artifact.rs","line":17},".family":{"file":"/home/rett/open/artifact/tests/data_family.rs","line":17},".name":{"file":"/home/rett/open/artifact/tests/data_name.rs","line":17},".raw_name":{"file":"/home/rett/open/artifact/tests/data_raw_names.rs","line":17},".read_impl":{"file":"/home/rett/open/artifact/tests/data_implemented.rs","line":17}}}},"artifacts":{"REQ-data":{"id":"ZuHTV2mKtmWyp6SeP9FqZw","name":"REQ-data","file":"/home/rett/open/artifact/design/data/purpose.md","partof":["REQ-purpose"],"parts":["SPC-family","SPC-impl","SPC-lint","SPC-modify","SPC-name","SPC-read","SPC-structs","SPC-test"],"completed":{"spc":0.6,"tst":0.347},"text":"\nThe `artifact-data` crate defines a lightweight and robust API for\ndeterministically deserializing, processing and reserializing artifacts from a\nproject directory.\n\nThis crate treats an \"artifact project\" (which is a path to a folder\ncontaining a `.art/` directory) as a transactional database, ensuring\nconsistency and validity when any update is made. It does this by creating a\nunique-hash of the reduced form of any artifact, and requires all updates to\nthat database to have the *correct* original unique-hash before updates are\nallowed.\n\nThis allows external applications to use the filesystem *itself* as a \"database\"\nof sorts, and allows you to simultaniously edit artifacts via (for example)\n*both* a Web-UI *and* a local text-editor and see real-time updates in both\nplaces -- without having to worry about loosing any of your work.\n\nThese requirements are implemented through the following specifications:\n- [[SPC-read]]: the \"read\" part of the CRUD database. Allows you to load an\n  artifact project.\n- [[SPC-modify]]: the \"Create + Update + Delete\" part of the CRUD database.\n- [[SPC-structs]]: the exported types of this module and their purpose.\n- [[SPC-name]]: the valid types of artifacts and the attrs in their name.\n- [[SPC-family]]: the valid and automatic relationships between artifacts\n- [[SPC-impl]]: how artifacts are implemented.\n- [[SPC-lint]]: the design of error handling (spoiler: it's all \"lints\")\n\nThe following test helpers are exported under feature flag `test-helpers`:\n- [[TST-fuzz]]: this library shall export **and use** fuzz testing primitives\n  throughout its infrastructure\n- [[TST-framework]]: this library shall export **and use** a testing framework\n  which allows you to express the expected state of a project _as only data_\n  and which makes clear assertions using these expected values.\n","impl_":{"type":"NotImpl"},"subnames":[]},"REQ-purpose":{"id":"P6bwvXuT9Bt8a1gjgUj0Kg","name":"REQ-purpose","file":"/home/rett/open/artifact/design/purpose.md","partof":[],"parts":["REQ-data","REQ-web","SPC-cli","TST-framework"],"completed":{"spc":0.457,"tst":0.337},"text":"> This is a work in progress\n>\n> These are the design documents. For user documentation\n> see the project's [README][artifact].\n\n**These are the developer design documents. For user documents and project\ninformation, see the project's [README][artifact].**\n\n## Overview for Artifact\nThe goal of artifact is to be a simple, linkable and trackable design\ndocumentation tool for everybody.\n\nThis may seem trivial, but it's not. A useful design doc tool must have *at least*\nthe following characteristics:\n- Allow simple linking of requirements -> specifications -> tests.\n- Easily link to source code (through the source documentation) to determine\n  completeness.\n- Be revision controllable (text based).\n- Have a unix-like command line interface for interacting with your design docs.\n- Have a web-ui for viewing and editing rendered documents.\n- Provide interop functionality like subcommand and data export for integration\n  with external tools and plugins.\n- Be scalable to any size of project (i.e. fast+cached).\n\nThese features will empower developers to track their own design docs and make\nit possible for them to use their design docs to provide documentation and\nguidance for contributors and teamates.\n\n[artifact]: https://github.com/vitiral/artifact\n\n## What is an \"Artifact\"?\n`artifact` allows the user to define any number of what it calls \"Artifacts\".\nAn Artifact is simply a part of a document (i.e. json, toml or extended\nmarkdown) which:\n- Is a single entity composed of a specific set of attributes defined below.\n- [[SPC-name]]: Has a project-wide unique `Name` beginning with one of `REQ`,\n  `SPC` or `TST`, which is the artifact's `Type` ([[SPC-name.type]]).\n- [[SPC-family]]: Has a `partof` attribute which makes it a dependency of other\n  artifacts.\n- [[SPC-impl]]: Has a `text` attribute which allows you to write out the\n  artifact's specification, as well as create subnames which can be linked in\n  source code (i.e. `ART-name.subname`)\n  - [[SPC-impl.done]]: alternatively can be forced as implemented through the\n    `done` attribute\n- [[SPC-read-impl]]: Can be linked in source code using `#ART-name` or\n  `#ART-name.subname`, which allows you to \"implement\" the artifact directly.\n- [[SPC-read-artifact.completed]]: Tracks spc and tst completion of\n  artifacts by (roughly) averaging the completeness of their children + the\n  completion of their subparts, where TST's only affect the TST completion of\n  REQ and SPC.\n\nArtifacts are first and formost intended to be simple and lightweight. They\ntry to stay out of your way and *express what you want, when you want it*.\n\n## Design Architecture\nThe design of artifact is split into several sub-modules\n\n- [[REQ-data]]: the \"data\" module, which acts as a filesystem database for CRUD\n  operations on the user's artifacts.\n- [[SPC-cli]]: The CLI interface. Artifact always aims to be a \"developer first\" tool, and\n  having a full featured CLI with search+lint+export commands is one of the ways it\n  accomplishes that goal.\n- [[REQ-web]]: the webui frontend/backend implementation, which is one of the\n  main ways that users actually use artifact.\n","impl_":{"type":"NotImpl"},"subnames":[]},"REQ-web":{"id":"G7qmEVmzQJ-YmXTMxQAJxA","name":"REQ-web","file":"/home/rett/open/artifact/design/purpose.md","partof":["REQ-purpose"],"parts":["SPC-frontend"],"completed":{"spc":0.0,"tst":0.0},"text":"The web interface for artifact should be designed to behave very similar to the\nCLI/text based interface, except it should take advantage of everything that a web\ninterface can.\n\nMain attributes:\n- Works directly on the file system. Any database introduced should only be used for improving performance (invisible to the user).\n- [[.secure]]: this is definitely TODO, not sure how it will be accomplished ATM. Probably just require non-local host hosting to require a password and use HTTPS (nothing crazy).\n- Fast for _single users and small groups_. Explicitly not designed as a whole org editing portal, users are encouraged to make small changes and use existing code review tools for changing design docs.\n\n# Architecture\nThe basic architecture of the web UI is split into two components:\n- [[.backend]]: this will be a simple json-rpc server which uses the [[REQ-data]] crate\n  to do all of it's heavy lifting. [[REQ-data]] will ensure data consistency and error\n  handling.\n- [[.frontend]]: the frontend will be a single page application which\n  accomplishes a majority of the goals of artifact, including real-time\n  feedback, graphing and visualization of requirements. It and the CLI are the\n  two major \"user facing\" components of artifact.\n","impl_":{"type":"NotImpl"},"subnames":[".backend",".frontend",".secure"]},"SPC-cli":{"id":"AbESDYYLakq0qimrqgTz_w","name":"SPC-cli","file":"/home/rett/open/artifact/design/cli.md","partof":["REQ-purpose"],"parts":["SPC-cli-ls"],"completed":{"spc":0.771,"tst":0.0},"text":"\nThe CLI is the primary developer interatction with artifact, alongside the Web\nUI for visualizing the artifacts. The main goal of the CLI is to provide the\ntools that every developer is used to in a typical development tool. This\nincludes:\n\n\n- [[.init]]: Initialize a project for using artifact. This is pretty basic, just need\n  a `.art` folder with a `settings.toml` and an initial `design/` folder.\n- [[.check]]: checking for errors AND warnings with a return code if there is an error.\n    - If there are only warnings the return code == 2. Otherwise it == 1.\n- [[.fmt]]: auto format the project.\n  - `--type` flag to change the filetype.\n- [[SPC-cli-ls]]: listing/searching for artifacts, see the full specification.\n- [[.serve]]: the command to start the web backend.\n\n\nAll subcommands should include the following flags:\n- `-v / --verbose` for setting the logging verbosity.\n- `--work-dir` for setting the working directory to run the command out of.\n","impl_":{"type":"Code","value":{"primary":{"file":"/home/rett/open/artifact/src/lib.rs","line":59},"secondary":{".check":{"file":"/home/rett/open/artifact/src/check.rs","line":34},".fmt":{"file":"/home/rett/open/artifact/src/fmt.rs","line":38},".serve":{"file":"/home/rett/open/artifact/src/serve/mod.rs","line":16}}}},"subnames":[".check",".fmt",".init",".serve"]},"SPC-cli-ls":{"id":"bVaFhTb1AalKMbrKY6hYUg","name":"SPC-cli-ls","file":"/home/rett/open/artifact/design/cli.md","partof":["SPC-cli"],"parts":[],"completed":{"spc":0.625,"tst":0.0},"text":"The `art ls` command shall be used to list information about the artifacts in a\nproject.\n\n`ls` is the primary window into a user's artifacts, creating a simple interface\nto glimpse large amounts of information.\n\n## [[.args]]: Arguments\n`art ls` with no commands will simply print all artifacts with standard\nsettings, each on a single line.\n\nThe args are as follows:\n- `SEARCH str`: positional argument detailing which artifacts to display\n  By default, this will be interpreted as an Artifact Name and can therefore\n  only display one artifact. However, if pattern searching is selected, it\n  will be interpreted as a rust regexp\n- `display`: flags that control what information will be displayed\n- `pattern`: searh SEARCH with a regex pattern. The flag specifies which fields\n  should be searched.\n- `completed/tested`: flags which control what percentage completed/tested to\n  display\n- [[.long]]: the `-l` flag prints the artifact in \"long\" form. Without it it\n  is printed in [[.table]] form.\n\n## [[.color]]: Color\nIn order to make viewing of information via cmdline easier, artifact **shall**\ncolorize it's output to make it clear which items are done or not done or in\nerror.\n\nThe following are the general rules:\n- Names that are complete will be `green`.\n- Names that are almost complete will be `blue`.\n- Names that are somewhat complete will be `yellow`.\n- Names that are very litle or not complete will be `red`.\n- Names that are in ERROR will be `bold red`.\n\nFor [[.color_spc]], the levels are:\n- `( 100%,  70%,    40%,  0%)`: percentage spc\n- `(    3,    2,      1,   0)`: points\n- `(green, blue, yellow, red)`: colors\n\nFor [[.color_tst]], the levels are:\n- `( 100%,    50%,  0%)`: percentage tst\n- `(    2,      1,   0)`: points\n- `(green, yellow, red)`: colors for tst\n\nFor [[.color_name]] you add the two points together:\n- 5: Name is Green\n- 3-4: name is blue\n- 1-2: name is yellow\n- 0: name is red\n","impl_":{"type":"Code","value":{"primary":{"file":"/home/rett/open/artifact/src/ls.rs","line":16},"secondary":{".args":{"file":"/home/rett/open/artifact/src/ls.rs","line":31},".color_name":{"file":"/home/rett/open/artifact/src/ls.rs","line":597},".color_spc":{"file":"/home/rett/open/artifact/src/ls.rs","line":574},".color_tst":{"file":"/home/rett/open/artifact/src/ls.rs","line":586}}}},"subnames":[".args",".color",".color_name",".color_spc",".color_tst",".long",".table"]},"SPC-family":{"id":"KM4o_JgTWvkXLuJZKcQddQ","name":"SPC-family","file":"/home/rett/open/artifact/design/data/family.md","partof":["REQ-data"],"parts":[],"completed":{"spc":0.5,"tst":0.0},"text":"An artifact (name) has the following \"family\" defined:\n\n```dot\ndigraph G {\n    subgraph cluster_allowed {\n        label=<<b>allowed partof</b>>;\n        REQ -> SPC -> TST;\n        REQ -> TST;\n\n        REQ -> REQ;\n        SPC -> SPC;\n        TST -> TST;\n    }\n\n    subgraph cluster_relationship {\n        label=<<b>auto family</b>>;\n        \"REQ-root\"\n            -> {\"REQ-root-child\" [color=blue]}\n            [label=\"is parent of\"; color=blue; fontcolor=blue];\n        \"REQ-root\" -> \"SPC-root\" [label=\"is auto-partof\"];\n        \"SPC-root\"\n            -> {\"SPC-root-child\" [color=blue]}\n            [label=\"is parent of\"; color=blue; fontcolor=blue];\n        \"SPC-root\" -> \"TST-root\" [label=\"is auto-partof\"];\n    }\n}\n}\n```\n\n## Allowed Partof\nThe first graph shows what relationships are \"allowed\". It specifies that:\n- `REQ` can be `partof` any type\n- `SPC` can be `partof` `SPC` and `TST`\n- `TST` can only be `partof` itself.\n\nIn essense:\n- You can always create \"subtypes\", i.e. a more specific requirement\n- You can create a specification that is \"partof\" a requirement. This makes\n  sense as you want to define your specifications based on your requirements.\n- You can create a test that is \"partof\" a specification OR a requirement.\n  For example, white box testing will be based on a specification whereas\n  blackbox (\"requirements based\") testing will be based on a requirement.\n\n## Lints\nLints are required to make sure the above is upheld\n\n- [[.lint_partof_exists]]: Make sure any partof references actually exist.\n- [[.lint_types]]: Make sure that `partof` links are only made between valid types.\n\n## [[.auto]]: Auto Relationships\nThe second graph shows the \"automatic relationships\" of nodes to their\nparents.\n\n- A node is automatically a `partof` both its parent and it's auto-partof.\n- Artifacts that have only one element are \"root\" (i.e. REQ-root, REQ-foo, SPC-foo)\n- Any artifact that is *not* root has a single parent, which it will automatically\n  be a \"partof\". That parent **must** be defined by the user or it is a hard error\n- SPC and TST artifacts have auto-partof elements of the higher-order type (see\n  [[SPC-name]]. This element is **not required** to exist, but if it does\n  they will be linked automatically.\n\nA node can always be partof another node of the same type. In addition, the following type links are allowed\n\n```dot\n\n```\n","impl_":{"type":"Code","value":{"primary":null,"secondary":{".lint_partof_exists":{"file":"/home/rett/open/artifact/artifact-data/src/project.rs","line":163},".lint_types":{"file":"/home/rett/open/artifact/artifact-data/src/project.rs","line":183}}}},"subnames":[".auto",".lint_partof_exists",".lint_types"]},"SPC-frontend":{"id":"R14GAR8kRiYC5tXCeuT5rg","name":"SPC-frontend","file":"/home/rett/open/artifact/design/data/purpose.md","partof":["REQ-web"],"parts":[],"completed":{"spc":0.0,"tst":0.0},"text":"The frontend for artifact is probably the most important piece of design for creating\na pleasant user experience.\n\nThe frontend shall be presented as a single page application with the following\nmajor components:\n- [[.view]]: the user should be able to view an artifact and its relationship to other artifacts.\n- [[.edit]]: the user should be able to create, modify and delete artifacts.\n- [[.search]]: the user should be able to search artifacts and easily see how all artifacts\n  relate to each other.\n","impl_":{"type":"NotImpl"},"subnames":[".edit",".search",".view"]},"SPC-impl":{"id":"-Q8ojawNZ8KpPe20NC6SNw","name":"SPC-impl","file":"/home/rett/open/artifact/design/data/implemented.md","partof":["REQ-data"],"parts":["SPC-read-impl"],"completed":{"spc":0.25,"tst":0.708},"text":"Implementing artifacts is fairly straight forward:\n- [[.done]]: the artifact can define itself as done. If it does this, it must\n  not have any subnames and must not be implemented (linked) in source.\n- [[.subnames]]: subnames can be defined in the `text` field of the artifact\n  (see the beginning of this line for an example!)\n- [[SPC-read-impl]]: source code can link to either the artifact itself or one\n  of its subnames through `#ART-name` or `#ART-name.sub` respectively.\n-\n","impl_":{"type":"NotImpl"},"subnames":[".done",".subnames"]},"SPC-lint":{"id":"eadWD3FdcjyujgYZmZlZJw","name":"SPC-lint","file":"/home/rett/open/artifact/design/data/purpose.md","partof":["REQ-data"],"parts":[],"completed":{"spc":1.0,"tst":0.0},"text":"## Lint Design\n\n> The design of how linting will be handled is very important to the simplicity\n> of the data flow. Often times \"warning\" and \"non-fatal\" level errors are\n> overlooked in the initial design, even put to the job of global logging\n> handlers. It is intended that that is avoided here.\n\nThe basic design of lints is that:\n- Every \"error\", no matter how severe, should always be cast into a lint.  We\n  load lots of files, it is better to simply list all errors rather than fail\n  at each one individually.\n- Loading lints should be errors and the calling functions are *required* to\n  not proceed if there are load errors.\n- Other lints should always be *repeatable*, meaning you can rerun the lints\n  or even run lints on a project passed by some other means (i.e. from a\n  json-rpc call).\n\n## Basic Design\n\nThe `Lint` type is:\n```\nenum Lint {\n    level: Level,\n    category: Category,\n    path: Option<PathBuf>,\n    line: Option<u64>,\n    msg: String,\n}\n\n#[derive(Hash)]\nenum Category {\n    ParseCodeImplementations,\n    ParseArtifactFiles,\n    ... etc\n}\n\nenum LintMsg {\n    Error(String),\n    Warn(String),\n}\n```\n\nThe intention is that `Level::Error` will cause an application built on artifact\nto *not continue* to any final steps where as `Lint::Warn` will only be printed.\n\nWhen printing lints (at the application level) they should be sorted and\ngrouped by their categories+files. Each lint should be printed on their own\nline.\n","impl_":{"type":"Code","value":{"primary":{"file":"/home/rett/open/artifact/artifact-ser/src/lint.rs","line":16},"secondary":{}}},"subnames":[]},"SPC-modify":{"id":"smwTHpVolY4hojGSvA20hA","name":"SPC-modify","file":"/home/rett/open/artifact/design/data/modify.md","partof":["REQ-data"],"parts":["SPC-modify-update","TST-fuzz","TST-unit"],"completed":{"spc":0.75,"tst":0.708},"text":"The modify operation takes in only the `project_path` and an array of\n`ArtifactOp` (see [[SPC-structs]]).\n\nFrom there, the control flow and high level architecture are\nas follows:\n\n```dot\ndigraph G {\n    node [\n        shape=box;\n    ];\n\n    edge [weight=10];\n\n    {start [shape=oval]}\n        -> {read1 [label=\"read(project_path)\" shape=cylinder]}\n        -> {if_compare_id [\n            label=\"compare ids: orig w/ load?\"]}\n        -> {update [\n            label=\"perform updates and\\n create new project\"]}\n        -> {backup [label=\"backup orig files\" shape=cylinder]}\n        -> {save [label=\"save new project to disk\" shape=cylinder]}\n        -> {read2 [label=\"read(project_path)\" shape=cylinder]}\n        -> {clean [label=\"clean (delete)\\nbackup files\" shape=cylinder]}\n        -> {return [label=\"return new project\" shape=oval]};\n\n    // error paths\n    read1 -> {read1_err [label=\"ERR: db\\ncorrupted by user\"\n        shape=oval fontcolor=red]}\n        [label=err fontcolor=red];\n    if_compare_id -> {compare_err [label=\"ERR: not\\nupdated\"\n        shape=oval fontcolor=red]}\n        [label=err fontcolor=red];\n    update -> {update_err [\n        label=\"ERR: return lints\" shape=oval fontcolor=red]}\n        [label=err fontcolor=red];\n    read2 -> {restore [label=\"restore backups\" fontcolor=red shape=cylinder]}\n        [label=err fontcolor=red];\n    restore -> {read2_err [label=\"ERR: internal error\"\n        fontcolor=red shape=oval]};\n\n    {rank=same {read1, read1_err}};\n    {rank=same {if_compare_id, compare_err}};\n    {rank=same {update, update_err}};\n    {rank=same {read2, restore}};\n    {rank=same {clean, read2_err}};\n}\n```\n\nOverall this is *relatively simple*. The only new stuff is:\n- [[.compare_id]]: compare the `orig_hash` of the requested changes to the hashes\n  of the loaded values. If they don't match it means that the person requesting changes\n  did so *with an out of date version of the artifact*. This is a no-no!\n- [[SPC-modify-update]]: update the loaded project with the requested changes.\n- [[.backup]]: backup files by moving them to (for example) `path/to/file.md` ->\n  `path/to/file.md.art_bk`. Restoring is just moving them back to their\n  original place. Cleaning is just deleting them.\n\n> This requires a LOT of filesystem operations, some of them seemingly\n> redundant. However, I believe all of them are justified. Theoretically we\n> could remove the \"checking\" one at the very end, but I prefer to keep it for\n> a *very* long time.\n","impl_":{"type":"Code","value":{"primary":{"file":"/home/rett/open/artifact/artifact-data/src/modify.rs","line":0},"secondary":{".backup":{"file":"/home/rett/open/artifact/artifact-data/src/modify.rs","line":229}}}},"subnames":[".backup",".compare_id"]},"SPC-modify-update":{"id":"-s7-03uLafa4wUTOH4a6YA","name":"SPC-modify-update","file":"/home/rett/open/artifact/design/data/modify.md","partof":["SPC-modify"],"parts":["TST-fuzz","TST-unit"],"completed":{"spc":1.0,"tst":0.708},"text":"We are given a `Vec<ArtifactOp>` and loaded `Project` and we want to perform\nthe requested updates on the project, ensuring there are no new errors.\n\nThe basic process is:\n- Ensure that there are no conflicts in the `ArtifactOp`'s original `HashIm`s\n  or new `HashIm`s. For instance, ensure that they aren't trying to delete\n  and create the same `HashIm`.\n- We _already have_ the project as a `Map<HashIm, ArtifactIm>`.\n- Note: we don't care in the next phase about whether `Name`s colide. We are\n  hashed by `HashIm`, NOT by `Name`!\n- We simply perform the operations requested -- blindly changing the artifacts.\n  - `ArtifactOp::Create` is inserting the `HashIm` into the map with the new\n    artifact.\n  - `ArtifactOp::Update` is removing the original `HashIm` and inserting the\n    new one.\n  - `ArtifactOp::Delete` is deleting the requested `HashIm`\n- We then rebuild the project and do all _error level_ lints.\n","impl_":{"type":"Code","value":{"primary":{"file":"/home/rett/open/artifact/artifact-data/src/modify.rs","line":184},"secondary":{}}},"subnames":[]},"SPC-name":{"id":"Qb21so6lliMxgkjRMDpmPQ","name":"SPC-name","file":"/home/rett/open/artifact/design/data/name.md","partof":["REQ-data"],"parts":["TST-fuzz","TST-unit"],"completed":{"spc":1.0,"tst":0.708},"text":"The following attributes must be definable by the user:\n- `name`: the artifact name must be given in the form `ART-name`, where `ART`\n  is used to determine the type (see below).\n- `done`: if any string is given, the artifact is \"defined as done\", meaning it\n  is 100% complete for both implementation and test.\n- `partof`: a list (or compressed syntax) of artifact names which this artifact\n  is a \"partof\". Valid and automatic links are defined in [[SPC-family]].\n- `text`: the description of the artifact which can contain \"soft links\" to\n  other artifacts as well as to code implementations.\n\n## [[.type]]:  Artifact Type\nThe type of an artifact is simply its prefix, which must be one of:\n- `REQ`: requirement\n- `SPC`: design specification\n- `TST`: test specification\n\nThe order of precedence is:\n- `REQ` is \"higher order\" than `SPC` or `TST`\n- `SPC` is \"higher order\" than `TST`\n\n```dot\ndigraph G {\n    graph [rankdir=LR; splines=ortho]\n    REQ -> SPC -> TST\n}\n```\n\nSee [[SPC-family]] for how these are related.\n\n## [[.attrs]]: Attributes/Getters\n\nThe `Name` type shall be the exported \"key\" of artifacts.  Internally it is\nreference counted, externally it exposes itself with the following methods:\n- `Name.ty`: get the name's type\n- `Name.from_str(s)`: create or automatically load the name.\n- `Name.as_str()`: get the string representation of the name. This must always\n  be the same string as the user gave.\n- `Name.key_str()`: get the name's \"key\" representation\n\nInternally the name is an atomically reference counted pointer (`Arc`), meaning\nthat cloning it is extremely cheap.\n","impl_":{"type":"Code","value":{"primary":{"file":"/home/rett/open/artifact/artifact-ser/src/name.rs","line":16},"secondary":{".attrs":{"file":"/home/rett/open/artifact/artifact-ser/src/name.rs","line":210},".type":{"file":"/home/rett/open/artifact/artifact-ser/src/name.rs","line":98}}}},"subnames":[".attrs",".type"]},"SPC-read":{"id":"2iQY9xpnrk-gS9lkuvDVYQ","name":"SPC-read","file":"/home/rett/open/artifact/design/data/purpose.md","partof":["REQ-data"],"parts":["SPC-read-artifact","SPC-read-cache","SPC-read-family","SPC-read-impl","SPC-read-raw","TST-fuzz"],"completed":{"spc":0.8,"tst":0.648},"text":"The control flow and high level architecture for deserializing and processing\nartifact data are defined below. The types are defined in [[SPC-structs]].\n\n```dot\ndigraph G {\n    node [shape=box];\n\n    subgraph cluster_start {\n        {start [label=\"paths to parse\"; shape=oval ]}\n     }\n    subgraph cluster_src {\n        label=<<b>parse src code links</b>>;\n        start -> [[SPC-read-impl]];\n    }\n    subgraph cluster_artifacts {\n        label=<<b>parse artifacts</b>>;\n        start -> [[SPC-read-raw]]\n            -> [[SPC-read-family]];\n        \"SPC-DATA-RAW\";\n    }\n\n\n    // join main and branch\n    \"SPC-DATA-SRC\" -> [[SPC-read-artifact]];\n    \"SPC-DATA-FAMILY\" -> \"SPC-DATA-ARTIFACT\"\n      -> [[SPC-lint]]\n      -> {done [shape=oval]};\n}\n```\n\nThe following are major design choices:\n- **join-data**: combine the data from the indenpendent (parallizable) streams.\n- [[SPC-test]]: the overall testing architecture\n\nThere are the following subparts, which are also linked in the graph above:\n- [[SPC-read-impl]]: \"deserialize\" the source code and extract the links to\n  artifacts\n- [[SPC-read-raw]]: deserialize the artifact files into \"raw\" data.\n- [[SPC-name]]: deserialize the artifact names into objects.\n- [[SPC-read-family]]: Determine the family of the artifats.\n- [[SPC-read-artifact]]: join the data and calculate the remaining pieces of\n  the artifact.\n","impl_":{"type":"NotImpl"},"subnames":[]},"SPC-read-artifact":{"id":"t_b23fTOvZg0N_EvtEA1OQ","name":"SPC-read-artifact","file":"/home/rett/open/artifact/design/data/artifact.md","partof":["SPC-read"],"parts":["TST-fuzz","TST-read-artifact","TST-unit"],"completed":{"spc":1.0,"tst":0.806},"text":"The artifact type itself must be constructed from its joined parts.\n\nThe design up until this point has been to create mappings of\n`Name => piece`, where `piece` is something needed to construct\nthe artifact. That design will continue here to allow for reduced\ncomplexity and easier testability (where needed).\n\n# [[.load]]: calculate pieces from ArtifactRaw only\nAfter we have successfully loaded all of the artifacts we still want\nto calculate all of the pieces such as `partof`, `parts` and `subnames`.\n\nThis is fairly straightforward, but the following should be kept in\nmind.\n- `subnames` is a simple iterative regexp search of `text`\n- `partofs` simply has to concatenate any auto-partof values from the `family`\n  module (see [[SPC-read-family.auto]]).\n- Create a graph from `partofs` and use it to calculate `parts`. We need the\n  graph later anyway.\n\n# [[.build]]: build the artifact from its parts\nAfter we have successfully loaded and finalized the artifact pieces, we need\nto combine them with the implementations and calculate completeness.\n\nThis mostly just has to make use of the functions defined in FIXME\n\n## [[.graph]]: construction of the graph\nThe construction of the graph takes a map of each artifact to its given+auto\n`partof` field, which defines the reverse directed edges of the graph.\n\nWe requre three graphs:\n- `full`: this is primarily used to compute the `parts` field and to later lint\n  that there are no cycles in the graph.\n- `lookup_name`: map of `id => name`\n- `lookup_id`: map of `name => id`\n\n## [[.completed]]: compute the `Completed` objects.\nWhen computing completeness we are basically trying to solve for dependencies.\nA graph can help significantly in this by giving us the topological sort.\nThe toplological sort guarantees that any item can be calculated if its\nitems to its right are are calculated.\n\nThere are a couple of artifact-specific points to keep in mind:\n- TST `spc` completenss is always equal to it's `tst` completeness.\n- TST does not contribute towards the `spc` completeness of non-TST types.\n- We have to account for the `impl` field on each artifact.\n\nOther than that, we simply:\n- Solve for the `graph_tst`, setting `completed.tst = completed.spc` for each\n  of its items\n- Solve for the `graph_req_spc`, knowing that any `graph_tst` dependencies\n  have already been solved.\n- If any cycles are detected we just return that all items are 0% completed.\n  A later lint will handle that issue.\n\n## Lints\n- [[.lint_text]]: ensure that the artifat's text is valid in all of the\n  formats. For markdown, this means ensuring that nothing would be parsed\n  as \"a new artifact\" or the \"end of metadata\" blocks.\n- [[.lint_done]]: ensure that done and subnames are not both defined.\n- [[.lint_text_refs]]: ensure that soft references (`[[ART-name(.sub)]]`)\n  all point to real things.\n","impl_":{"type":"Code","value":{"primary":{"file":"/home/rett/open/artifact/artifact-data/src/artifact.rs","line":17},"secondary":{".build":{"file":"/home/rett/open/artifact/artifact-data/src/artifact.rs","line":57},".completed":{"file":"/home/rett/open/artifact/artifact-data/src/graph.rs","line":71},".graph":{"file":"/home/rett/open/artifact/artifact-data/src/graph.rs","line":33},".lint_done":{"file":"/home/rett/open/artifact/artifact-data/src/project.rs","line":214},".lint_text":{"file":"/home/rett/open/artifact/artifact-data/src/project.rs","line":300},".lint_text_refs":{"file":"/home/rett/open/artifact/artifact-data/src/project.rs","line":335},".load":{"file":"/home/rett/open/artifact/artifact-data/src/artifact.rs","line":33}}}},"subnames":[".build",".completed",".graph",".lint_done",".lint_text",".lint_text_refs",".load"]},"SPC-read-cache":{"id":"QJES3v3iIFXg6UtDxmtcBw","name":"SPC-read-cache","file":"/home/rett/open/artifact/design/data/cache.md","partof":["SPC-read"],"parts":[],"completed":{"spc":0.0,"tst":0.0},"text":"> This specification only exists to improve performance\n\nSignificant speed gains can be made by caching artifact data into a local\nSQLite database in `.art/db.sql`. For linux specifically (and probably MacOS,\ndon't know about windows) you can get the timestamp when any file was modified.\n\n- If we only parsed files where the timestamp changed we could speed things up\n  significantly for just querying their results from an sql database. This is\n  especially true for files that don't have *any* links.\n","impl_":{"type":"NotImpl"},"subnames":[]},"SPC-read-family":{"id":"KTvK7icLyptoc5r2R2ITQw","name":"SPC-read-family","file":"/home/rett/open/artifact/design/data/family.md","partof":["SPC-read"],"parts":["TST-fuzz","TST-unit"],"completed":{"spc":1.0,"tst":0.708},"text":"The method of determining family is fairly straightforward, as is\ndetailed in the graph below:\n\n```dot\ndigraph G {\n    [[.parent]] -> { \"if\" [label=\"if elem-len > 1\"; shape=diamond] };\n    \"if\" -> \"return None\" [label = \"no\"];\n    \"if\" -> {\"clone raw string\" [\n        shape=box;\n    ]} -> {\"pop last element and create new Name\" [\n        shape=box;\n    ]} -> \"return new name\";\n\n    [[.auto_partof]] -> { if_req [label=\"type is REQ\"; shape=diamond] };\n    if_req -> \"return None\" [label=\"yes\"];\n    if_req -> {\"get higher-order type\" [\n        shape=box;\n    ]} -> {\"clone raw name\" [\n        shape=box;\n    ]} -> {\"swap type with higher-order one\" [\n        shape=box;\n    ]} -> \"return new Name\";\n}\n```\n\n# [[.auto]]\nOnce family is created and the artifacts are loaded, the artifacts have\nto be automatically linked to their parent+auto_partof. This is easy\nto determine given the artifacts that exist.\n\nNote: make sure to ONLY link to artifacts that exists!\n\n# [[.deauto]]\nIn order to reserialize the artifacts, their \"auto\" partof has to be unlinked\n","impl_":{"type":"Code","value":{"primary":{"file":"/home/rett/open/artifact/artifact-ser/src/family.rs","line":16},"secondary":{".auto":{"file":"/home/rett/open/artifact/artifact-ser/src/family.rs","line":159},".auto_partof":{"file":"/home/rett/open/artifact/artifact-ser/src/family.rs","line":97},".deauto":{"file":"/home/rett/open/artifact/artifact-ser/src/lib.rs","line":277},".parent":{"file":"/home/rett/open/artifact/artifact-ser/src/family.rs","line":85}}}},"subnames":[".auto",".auto_partof",".deauto",".parent"]},"SPC-read-impl":{"id":"TKwNaBzmqN9SlGI0uV8VyA","name":"SPC-read-impl","file":"/home/rett/open/artifact/design/data/implemented.md","partof":["SPC-impl","SPC-read"],"parts":["TST-fuzz","TST-unit"],"completed":{"spc":1.0,"tst":0.708},"text":"## Loading source code (implementation) links\n\n### [[.load]]: Loading Locations\nThe process for loading implementation locations is fairly straightforward:\n- Define the regular expression of valid names. Valid names inclue:\n  - `SRC` and `TST` types ONLY.\n  - Any valid postfix name (i.e. `SPC-foo-bar-baz_bob`)\n  - (optional) a sub-name specified by a period (i.e. `SPC-foo.sub_impl`).\n- Walk the `code_paths`, iterating over each line for the regex and pulling\n  out any `Name` or `SubName` locations.\n\nThis results in two maps for each file:\n- `Name => CodeLoc`\n- `SubName => CodeLoc`\n\n## Lints\nAll lints related to source code are only WARNINGS\n\n- [[.lint_done]]: an artifact with its `done` field set is also linked\n  in code.\n- [[.lint_exists]]: the artifact name does not exists but it does not specify the\n  linked\n- [[.lint_subname_exists]]: the artifact name exists but the artifact does not specify\n  the linked subname.\n\n### [[.join]]: Joining Locations\nThe `Name` and `SubName` maps from each file are joined into two large maps\nrespectively (with any collisions put in the linting vectors which are also\njoined).\n\nWe must then construct a map of `Name => Implementation` in order for later\nsteps to construct the full `Artifact` object. We do this by:\n- Constructing a map of `Name => Map<SubName, CodeLoc>`, where `Name` is the\n  prefix/name of the underlying `SubName`s.\n- Building the `Name => Implementation` map by:\n  - Draining the `Name => CodeLoc` map and inserting `Implementation` objects.\n  - Draining the just created `Name => Map<SubName, CodeLoc>` and either\n    modifying or inserting `Implementation` objects.\n\n> Note: we do not worry about whether such `Name` or `SubName`s actually exist.\n> That is the job of a later linting step.\n","impl_":{"type":"Code","value":{"primary":{"file":"/home/rett/open/artifact/artifact-data/src/implemented.rs","line":16},"secondary":{".join":{"file":"/home/rett/open/artifact/artifact-data/src/implemented.rs","line":100},".lint_done":{"file":"/home/rett/open/artifact/artifact-data/src/project.rs","line":252},".lint_exists":{"file":"/home/rett/open/artifact/artifact-data/src/project.rs","line":264},".lint_subname_exists":{"file":"/home/rett/open/artifact/artifact-data/src/project.rs","line":278},".load":{"file":"/home/rett/open/artifact/artifact-data/src/implemented.rs","line":65}}}},"subnames":[".join",".lint_done",".lint_exists",".lint_subname_exists",".load"]},"SPC-read-raw":{"id":"ZXtpHMNCxDnGlwFB-e3Fxw","name":"SPC-read-raw","file":"/home/rett/open/artifact/design/data/raw.md","partof":["SPC-read"],"parts":["SPC-read-raw-markdown","TST-read-raw"],"completed":{"spc":1.0,"tst":1.0},"text":"Loading data shall be performed in a parallel fashion, where walking, reading\nand deserializing shall all happen simultaniously.\n\nThe basic method shall be:\n```\nfn load_path<T, F>(path: &Path, load: F) -> Result<HashMap<PathAbs, T>>\n    where F: Fn(s: &str) -> Result<T>\n```\n\nThe basic logic is:\n```dot\ndigraph G {\n    start -> {\"out = new Map\" [shape=box]}\n      -> {\"initialize walkdir for files\" [shape=box]}\n      -> {iter [label=\"next(walkdir)\"; shape=diamond]};\n\n    iter -> \"return out\" [label=\"empty\"; color=blue; fontcolor=blue];\n    iter -> {\"out.insert(fpath, load(fdata))\" [shape=box]}\n      -> iter;\n}\n```\n","impl_":{"type":"NotImpl"},"subnames":[]},"SPC-read-raw-markdown":{"id":"I1mUk-LQqloyTYFbABlCGg","name":"SPC-read-raw-markdown","file":"/home/rett/open/artifact/design/data/raw.md","partof":["SPC-read-raw"],"parts":["TST-read-raw"],"completed":{"spc":1.0,"tst":1.0},"text":"An artifact in the markdown format is specified as:\n\n    # <ART-name>\n    <optional yaml attributes: partof,done>\n    ### <optional, only if there were attributes\n    <text>\n\nThe process for loading markdown will be:\n- set `name,attrs,lines=None,None,[]`\n- read one line at a time\n- if the line is a name:\n    - `out.insert(name, ArtifactRaw {attrs=attrs, text='\\n'.join(lines)})`\n    - `name = line`\n    - continue\n- if the line is end of attrs:\n    - attrs = Some('\\n'.join(lines))\n    - lines = []\n    - continue\n- when the iterator is exhausted\n    - store ArtifactRaw with current values\n\n\n> This looks horrible and I don't know what to do, since the above is pretty\n> consise\n\n    ```dot\n    digraph G {\n    subgraph cluster_iter {\n        graph [rankdir=LR];\n        \"input=byte-stream\"\n            -> {\"out = new Map<Name, ArtifactRaw>\" [shape=box]}\n            -> {\"cur_name,cur_attrs,cur_lines=None,None,[]\" [shape=box]}\n            -> {iter [label=\"nextline(stream)\", shape=diamond]};\n        iter -> \"return out\" [label=\"empty\"; color=blue; fontcolor=blue];\n    }\n\n    subgraph cluster_name {\n        iter -> {if_name [label=\"name_re.match(line)?\"; shape=diamond]}\n            -> {\"if cur_name not None then out.append(current_stuff)\" [shape=box]}\n    //[label=\"yes\"; color=green; fontcolor=green]\n            -> {\"cur_name=match\" [shape=box]}\n            -> iter;\n    }\n    subgraph cluster_attrs {\n        if_name -> {if_attr [lable=\"attr_end_re.match(line)?\"; shape=diamond]}\n            -> {\"if attrs then ERROR\" [shape=box]}\n            -> {\"attrs=cur_lines; cur_lines=[]\" [shape=box]}\n           //     [label=\"yes\"; color=green; fontcolor=green]\n            -> iter;\n    }\n    }\n    ```\n","impl_":{"type":"Code","value":{"primary":{"file":"/home/rett/open/artifact/artifact-data/src/raw.rs","line":176},"secondary":{}}},"subnames":[]},"SPC-structs":{"id":"JxrG_nd2O1cgPK31crfYNA","name":"SPC-structs","file":"/home/rett/open/artifact/design/data/structs.md","partof":["REQ-data"],"parts":[],"completed":{"spc":0.5,"tst":0.0},"text":"This requirement details the high level `struct`s and `enum`s that must be\nexported by this module, as well as their features.\n\nIn many cases this would be a *specification*, but since this is a library,\nthe exported structs and their characteristics practically ARE the\nrequirement.\n\nIt's critical that the valid types are defined at a high level, since\nthey determine how everything works together.\n\n### Exported Types\nThese are the types that make up the exported \"product\" of this library. The\nmajor type is the **Artifact** and its associated **Name**.\n\nTODO: the original graph broke with the update to newer graphiz. Rewrite with the format below.\n\n```dot\ndigraph G {\n    node [shape=record];\n    Animal [\n        label =\n        \"{Animal\n        \\l|+ name : string\n        \\l+ age : int\n        \\l|+ die() : void\n        \\l}\"\n    ]\n}\n```\n\n### Raw Data Types\nThese types define the \"raw data\" format of artifact and are only used\nfor de/serializing.\n\n#### [[.artifact_raw]]: ArtifactRaw: (stored with key of `Name`)\n- done: `Option[String]`\n- partof: `Option[HashSet[Name]]`\n- text: `Option[TextRaw]`\n\n#### [[.text_raw]]: TextRaw: just a newtype with some serialization guarantees\nto make it prettier and ensure serialization is possible between\nall of the supported formats.\n\n### Intermediate (`Im`) Data Types\nIntermediate \"stripped down\" forms of the artifact. These types are used for:\n- linting after reading the project\n- inteacting with the CRUD interface.\n\n#### [[.artifact_op]]: ArtifactOp:\n- `Create(ArtifactIm)`: create an artifact, it must not already exist.\n- `Update(HashIm, ArtifactIm)`: update the artifact with the specified hash.\n- `Delete(HashIm)`: delete the artifact with the specifed hash.\n\nThis is the \"operation\" command used by [[SPC-modify]] for modifying artifacts.\n`Read` is ommitted as it is covered by [[SPC-read]].\n\n#### [[.artifact_im]]: ArtifactIm:\n- name: `Name`\n- file: `PathAbs`\n- partof: `Set<Name>` (auto-partofs are stripped)\n- done: `Option<String>`\n- text: `String`\n\nThe `ArtifactIm` is used to create a unique 128 bit hash of the artifacts and\nfor specifying *what* should be updated when an update is requested.\n\nThis is also the primary type used when linting.\n\n#### HashIm:\nThis is simply a 128 bit SipHash created by the [`siphasher` crate][1].\n\n[1]: https://doc.servo.org/siphasher/sip128/struct.Hash128.html\n\n\n## Type Details\n\n**Artifact**: ([[.artifact]]) the artifact is the primary exported type. It contains:\n  - `name`: the unique identifier of the artifact.\n  - `file`: the file where the artifact is defined.\n  - `partof` and `parts`: automatic and user-defined relationship to other\n    artifacts where `B in A.partof` means that B is a \"parent\" of A.\n    More details are in [[SPC-family]].\n  - `completed`: the `spc` and `tst` completion ratios, detailing how much of\n    the artifact's specification and test design has been implemented.\n  - `text`: the user defined text in the markdown format.\n  - `impl_`: how the artifact is implemented (if it is implemented at all). Can\n    be `Done(str)`, `Code(ImplCode)` or `NotIMpl`.\n  - `subnames`: a list of subnames defined in `text` using `{{.subname}}`\n    except `[[]]` instead of `[[]]`. These can be linked in code to complete\n    the artifact.\n  - `orig_hash`: the original hash of the `ArtifactIm` this was created from.\n\n**Name**:\n  - name is of the form `ART-name` where ART is one of {`REQ`, `SPC` or `TST`}\n  - more details are in [[SPC-name]].\n\n**Impl**:\n  - Defines how the artifact is implemented.\n  - `Done`: can be \"defined as done\" through the `done` field in the\n    `ArtifactRaw`.\n  - `Code`: can be implemented in code, where source code just puts `#ART-name`\n    anywhere to mark an artifact as implemented.\n","impl_":{"type":"Code","value":{"primary":null,"secondary":{".artifact":{"file":"/home/rett/open/artifact/artifact-lib/src/lib.rs","line":51},".artifact_im":{"file":"/home/rett/open/artifact/artifact-lib/src/lib.rs","line":231},".artifact_op":{"file":"/home/rett/open/artifact/artifact-lib/src/lib.rs","line":301}}}},"subnames":[".artifact",".artifact_im",".artifact_op",".artifact_raw",".text_raw"]},"SPC-test":{"id":"AYk5W1Wpn-jCLnlY262ZIg","name":"SPC-test","file":"/home/rett/open/artifact/design/data/purpose.md","partof":["REQ-data"],"parts":[],"completed":{"spc":0.0,"tst":0.0},"text":"This requirement details the *exported* functions, classes and framework for\nmaking testing artifact projects simpler and more robust.\n\nThere are three pieces of this requirement:\n- Definition of exported \"helper\" methods and types for testing  artifact.\n  This is not defined further, but should be clear from reading the test source\n  code documents.\n- Definition of exported \"fuzzing\" methods for fuzz testing artifact\n- Definition of exported \"test framework\" for creating examples and assertions\n  using a simple file structure.\n","impl_":{"type":"NotImpl"},"subnames":[]},"TST-framework":{"id":"sKZG1tS5OiKLfzyYXoanLQ","name":"TST-framework","file":"/home/rett/open/artifact/design/data/purpose.md","partof":["REQ-purpose"],"parts":[],"completed":{"spc":1.0,"tst":1.0},"text":"> TODO: make it partof REQ-data\n> partof: REQ-data\n> ###\n\nThere shall be a \"interop test framework\" constructed for doing interop testing.\nThe basic design is:\n- *Each test is a full project* (folder with a `.art` folder, source files and\n  design documents).\n- Each test contains assertions in various files. The assertions cover various\n  stages of loading the project:\n  - `project/assert_load_lints.yaml`: expected lints while loading.\n  - `project/assert_project.yaml`: the expected resulting project. If not included,\n    it is expected that the project is `None`.\n  - `project/assert_project_lints.yaml`: expected lints from linting the project.\n- The assertion files are an exact *explicit* version of the expected project.\n","impl_":{"type":"Code","value":{"primary":{"file":"/home/rett/open/artifact/artifact-test/src/framework.rs","line":16},"secondary":{}}},"subnames":[]},"TST-fuzz":{"id":"Cvij7hrOLZ8Yhfn9zNIv5A","name":"TST-fuzz","file":"/home/rett/open/artifact/design/purpose.md","partof":["SPC-modify","SPC-modify-update","SPC-name","SPC-read","SPC-read-artifact","SPC-read-family","SPC-read-impl"],"parts":[],"completed":{"spc":0.667,"tst":0.667},"text":"\nAll data objects shall be designed from the beginning to be fuzz tested, so\nthat even complex \"projects\" can be built up with random collections of\nartifacts in differing states.\n\nObviously this will also allow for fast fuzz testing of the smaller objects themselves.\n\nThe major workhorse here will be the [quickcheck][1] library. The following datatypes\nwill have `Abitrary` implemented for them and releated tests performed against them:\n- `Name` (and by extension `Partof`)\n- `InvalidName`\n- `RawArtifact`\n  - `Done`\n  - `CodeRef`\n  - `CodeLoc`\n  - `Text`\n- `RawCodeLoc`: simply a file with given code references inserted at random.\n- `HashMap<Name, RawArtifact>`\n- etc.\n\nFuzz testing will then involve the following:\n- positive fuzz tests: it should handle all generated cases that are expected\n  to work.\n- negative fuzz tests: it should handle all generated cacses that are expected\n  to fail properly.\n\n[1]: https://docs.rs/quickcheck/0.4.2/quickcheck/\n\n# Implementations\n- [[.raw_name]]\n- [[.name]]\n- [[.family]]\n- [[.read_impl]]\n- [[.artifact]]\n- [[.read]]\n- [[.modify]]\n- [[.modify_update]]\n","impl_":{"type":"Code","value":{"primary":{"file":"/home/rett/open/artifact/artifact-test/src/lib.rs","line":21},"secondary":{".artifact":{"file":"/home/rett/open/artifact/tests/data_artifact.rs","line":18},".family":{"file":"/home/rett/open/artifact/tests/data_family.rs","line":18},".name":{"file":"/home/rett/open/artifact/tests/data_name.rs","line":18},".raw_name":{"file":"/home/rett/open/artifact/tests/data_raw_names.rs","line":18},".read_impl":{"file":"/home/rett/open/artifact/tests/data_implemented.rs","line":18}}}},"subnames":[".artifact",".family",".modify",".modify_update",".name",".raw_name",".read",".read_impl"]},"TST-read-artifact":{"id":"peKkCquKF2lYwSxYGQop1Q","name":"TST-read-artifact","file":"/home/rett/open/artifact/design/data/artifact.md","partof":["SPC-read-artifact"],"parts":[],"completed":{"spc":1.0,"tst":1.0},"text":"Although the different pieces are separated out, most of the \"construction\" of\nthe artifact objects themselves will not be tested explicitly. Instead\nwe will rely on the framework to quickly test user scenarios.\n\nThe major testing will be done using the interop framework. The following\ntest cases should be implemented:\n- [[.empty]]: `empty` project that contains only empty artifact files.\n  and no source code.\n- [[.source_only]]: a project containing only source code (no design docs).\n- [[.source_invalid]]: a project containing invalid source code (invalid links).\n- [[.design_only]]: a project containing only design documents (none of the\n  artifacts implemented).\n  - This is mostly to test that artifact parsing works and linking works\n  - A few artifacts should be \"defined as done\" to get some basic \"completion\"\n    testing done as well.\n  - Artifacts should be split into lots of deep folders, to push parsing to\n    a higher limit.\n  - Some artifact folders should be excluded.\n- [[.basic]]: a basic project with minimal artifacts, some implemented in\n  source code.\n  - This is mostly a \"sanity\" project\n  - At least one artifact implemented in source\n  - At least one subname implemented in source\n  - At least one artifact with subnames NOT implemented in source\n  - At least one artifact only partially implemented (no subnames and not implemented)\n  - At least one artifact only partially implemented (no primary + single secondary)\n\n- [[.lints]]: a basic project to test lints\n  - Expected lint errors:\n    - referenes to names+subnames that don't exist\n    - partof values that don't exist\n    - At least one artifact BOTH implemenented in source and defined as done\n    - Invalid reference (name + subane) in source\n","impl_":{"type":"Code","value":{"primary":{"file":"/home/rett/open/artifact/tests/data_interop.rs","line":17},"secondary":{".basic":{"file":"/home/rett/open/artifact/tests/data_interop.rs","line":99},".design_only":{"file":"/home/rett/open/artifact/tests/data_interop.rs","line":93},".empty":{"file":"/home/rett/open/artifact/tests/data_interop.rs","line":75},".lints":{"file":"/home/rett/open/artifact/tests/data_interop.rs","line":105},".source_invalid":{"file":"/home/rett/open/artifact/tests/data_interop.rs","line":87},".source_only":{"file":"/home/rett/open/artifact/tests/data_interop.rs","line":81}}}},"subnames":[".basic",".design_only",".empty",".lints",".source_invalid",".source_only"]},"TST-read-raw":{"id":"e8VYtCr060Jk7j-stiZlzw","name":"TST-read-raw","file":"/home/rett/open/artifact/design/data/raw.md","partof":["SPC-read-raw","SPC-read-raw-markdown"],"parts":[],"completed":{"spc":1.0,"tst":1.0},"text":"Testing the deserialization shall require a small testing harness. The goal is that\nfunction from this harness be reused for writing even higher level tests.\n\nThe major elements of the harness are:\n- An `assert_deser_valid(deser, raw, expected)` which:\n    - converts `raw -> result` using `deser(raw)`\n    - asserts `expected == result`\n    - return value\n- An `assert_ser_valid(ser, value, expected)` which:\n    - converts `value -> raw` using `ser(value)`\n    - asserts `result == expected` with a decent diff\n    - return raw\n- An `assert_serde(value, expected_raw_toml, expected_raw_md)` function which:\n    - does a round trip on the inpult and asserts for all the given types\n    - `raw_toml = assert_ser_valid(toml::ser, value, expected_raw_toml)`\n    - `assert_de_valid(toml::de, raw_toml, value)`\n    - `raw_md = assert_ser_valid(from_markdown, value, expected_raw_md)`\n    - `assert_de_valid(to_markdown, raw_md, value)`\n- Fuzzing for `ArtifactRaw`, whch creates fuzzed ArtifactRaw objects and runs\n  round-trip tests on them.\n\nThe fuzzing design is of particular importance, since it is intended to be\nused by even higher level test frameworks. The design is the function\n```\nfuzz_raw_artifacts(these_names: Set<Name>, partofs: Graph)\n    -> BTreeMap<Name, ArtifactRaw>\n```\n- `these_names` is supposed to represent (loosely) the names that exist in\n  *this* single file (or representation of a file).\n- The `partofs: Graph` is a pre-constructed directed acyclic graph. It\n  is constructed as follows:\n  - the generated names are split into REQ, SPC and TST, their orders are\n    randomized, and then they are concattenated REQ++SPC++TST\n  - recall that the following \"partof\" connections are valid:\n    - REQ -> [REQ, SPC, TST] (requirement can be partof REQ SPC or TST)\n    - SPC -> [SPC, TST]\n    - TST -> TST\n  - A list of nodes that can be connected can treated as\n    [topologically sorted][1].  We just have to uphold this by only allowing\n    any node to only connect to its nodes to its right.\n  - A Graph is constructed and edges are added at random with exactly this\n    constraint\n- The rest of each Artifact is then created as follows:\n  - done is randomly defined or not defined. When defined it always had\n    len >= 1\n  - text is randomly defined or not defined. When defined it can have\n    any length <= 50 lines where each line be up to 120 characters\n    (this is only to make it more readable when debugging).  It also has the\n    following randomly inserted:\n    - references to *any* name that exists in `partofs`\n    - TODO: references to *any* subname that exists in `subnames`\n    - TODO: their own sublocations `{{.art}}` (except `[[]]` instead)\n\nLook into the following:\n- https://crates.io/crates/regex_generate: use regex to generate text\n    - I'm not sure if `\\\\w` works, but we should be able to use a character\n      class for arbitrary unicode ranges: https://doc.rust-lang.org/regex/regex_syntax/struct.ClassRange.html\n\n[1]: https://en.wikipedia.org/wiki/Topological_sorting\n","impl_":{"type":"Code","value":{"primary":{"file":"/home/rett/open/artifact/artifact-test/src/raw.rs","line":16},"secondary":{}}},"subnames":[]},"TST-unit":{"id":"mgAvS-OMaACSjpf3BSB2Gg","name":"TST-unit","file":"/home/rett/open/artifact/design/purpose.md","partof":["SPC-modify","SPC-modify-update","SPC-name","SPC-read-artifact","SPC-read-family","SPC-read-impl"],"parts":[],"completed":{"spc":0.75,"tst":0.75},"text":"\nSeveral low level specifications can be covered almost completely with unit\nand fuzz testing ([[TST-fuzz]]) testing.\n\nIn order for an item to consider itself \"unit tested\" it must:\n- test boundary conditions\n- test error conditions\n- test \"sanity\" use cases (standard use cases)\n\n\n# Implementations\n- [[.raw_name]]\n- [[.name]]\n- [[.family]]: this also inclused auto partofs as well as collapsing/expanding\n  partof.\n- [[.read_impl]]\n- [[.artifact]]\n- [[.modify]]\n- [[.modify_update]]\n","impl_":{"type":"Code","value":{"primary":{"file":"/home/rett/open/artifact/artifact-test/src/lib.rs","line":20},"secondary":{".artifact":{"file":"/home/rett/open/artifact/tests/data_artifact.rs","line":17},".family":{"file":"/home/rett/open/artifact/tests/data_family.rs","line":17},".name":{"file":"/home/rett/open/artifact/tests/data_name.rs","line":17},".raw_name":{"file":"/home/rett/open/artifact/tests/data_raw_names.rs","line":17},".read_impl":{"file":"/home/rett/open/artifact/tests/data_implemented.rs","line":17}}}},"subnames":[".artifact",".family",".modify",".modify_update",".name",".raw_name",".read_impl"]}}},"web_type":"Static"}